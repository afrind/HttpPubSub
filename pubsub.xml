<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.nl" -->
<rfc version="3" ipr="trust200902" submissionType="IETF" category="std" xml:lang="en" consensus="true" xmlns:xi="http://www.w3.org/2001/XInclude">

<front>
<title abbrev="bidirectional messaging">An HTTP/2 extension for bidirectional messaging communication</title><seriesInfo value="draft-xie-bidirectional-messaging-00" stream="IETF" status="standard" name="Internet-Draft"></seriesInfo>
<author initials="G." surname="Xie" fullname="Guowu Xie"><organization>Facebook Inc.</organization><address><postal><street>1 Hacker Way</street>
<city>Menlo Park</city>
<code>CA 94025</code>
<country>U.S.A.</country>
</postal><email>woo@fb.com</email>
</address></author>
<author initials="A." surname="Frindell" fullname="Alan Frindell"><organization>Facebook Inc.</organization><address><postal><street></street>
</postal><email>afrind@fb.com</email>
</address></author>
<date/>
<area>Internet</area>
<workgroup>httpbis Working Group</workgroup>
<keyword>Internet-Draft</keyword>

<abstract>
<t>This draft proposes a http2 protocol extension, which enables
bidirectional messaging communication between client and server.</t>
</abstract>

</front>

<middle>

<section anchor="introduction"><name>Introduction</name>
<t>HTTP/2 is the de facto application protocol in Internet. The optimizations
developed in HTTP/2, like stream multiplexing, header compression, and binary
message framing are very generic. They can be useful in non web browsing
applications, for example, Publish/Subscribe, RPC. However, the request/response
from client to server communication pattern limits HTTP/2 from wider use in
these applications. This draft proposes a HTTP/2 protocol extension, which
enables bidirectional messaging between client and server.</t>
<t>The only mechanism HTTP/2 provides for server to client communication is
PUSH<em>PROMISE. While this satisfies some use-cases, it is unidirectional, i.g.
the client cannot respond. In this draft, a new frame is introduced which has
the routing properties of PUSH</em>PROMISE and the bi-directionality of HEADERS.
Further, clients are also able group streams together for routing purposes, such
that each individual stream does not need to carry additional routing
information.</t>
</section>

<section anchor="conventions-and-terminology"><name>Conventions and Terminology</name>
<t>The keywords <bcp14>MUST</bcp14>, <bcp14>MUST NOT</bcp14>, <bcp14>REQUIRED</bcp14>, <bcp14>SHALL</bcp14>, <bcp14>SHALL NOT</bcp14>,
<bcp14>SHOULD</bcp14>, <bcp14>SHOULD NOT</bcp14>, <bcp14>RECOMMENDED</bcp14>, <bcp14>MAY</bcp14>, and <bcp14>OPTIONAL</bcp14>, when
they appear in this document, are to be interpreted as described in <xref target="RFC2119"></xref>.</t>
<t>All the terms defined in the Conventions and Terminology section in <xref target="RFC7540"></xref>
apply to this document.</t>
</section>

<section anchor="solution-overview"><name>Solution Overview</name>

<section anchor="routing-stream-and-exstream"><name>Routing Stream and ExStream</name>
<t>A routing stream (RStream) is a long lived HTTP/2 stream in nature. RStreams are
initiated by clients, and can be routed independently by any intermediaries.
Though an RStream is effectively a regular HTTP/2 stream, RStreams are
recommended for exchanging metadata, but not user data.</t>
<t>A new HTTP/2 stream called ExStream is introduced for exchanging user data.
ExStreams are recommended for short lived transactions, so intermediaries and
servers can gracefully shutdown ExStreams within a short time. The typical use
case can be a subscription or publish request/response in Publish/Subscribe use
case, or an RPC call between two endpoints.</t>
<t>An ExStream is opened by an EX_HEADERS frame, and continued by CONTINUATION and
DATA frames. An ExStream <bcp14>MUST</bcp14> be associated with an open RStream, and
<bcp14>MUST NOT</bcp14> be associated with any other ExStream. ExStreams are routed
according to their RStreams by intermediaries and servers. Effectively, all
ExStreams with the same RStream form a logical stream group, and are routed to
the same endpoint.</t>
</section>

<section anchor="bidirectional-messaging-communication"><name>Bidirectional Messaging Communication</name>
<t>With RStreams and ExStreams, HTTP/2 can be used for bidirectional messaging
communication. As shown in the follow diagrams, after an RStream is open from
client to server, either endpoint can initiate an ExStreams to its peer.</t>
<figure anchor="fig-client-to-server"><name>Client initiates the ExStream to server, after an RStream is open.
</name>
<artwork>+--------+   RStream (5)   +---------+    RStream (1)   +--------+
| client |&gt;---------------&gt;|  proxy  |&gt;----------------&gt;| server |
+--------+                 +---------+                  +--------+
    v                        ^     v                        ^
    |    ExStream(7, RS=5)   |     |    ExStream(3, RS=1)   |
    +------------------------+     +------------------------+
</artwork>
</figure>
<figure anchor="fig-server-to-client"><name>Server initiates the ExStream to client, after an RStream is open.
</name>
<artwork>+--------+   RStream (5)   +---------+    RStream (1)   +--------+
| client |&gt;---------------&gt;|  proxy  |&gt;----------------&gt;| server |
+--------+                 +---------+                  +--------+
     ^                        v     ^                        v
     |    ExStream(4, RS=5)   |     |    ExStream(2, RS=1)   |
     +------------------------+     +------------------------+
</artwork>
</figure>
<t>Beyond that, a client can multiplex RStreams, ExStreams and regular HTTP/2
streams into one single HTTP/2 connection. This enables clients to access
different services without initiating new transport layer connections. This
saves the latency of setting up new connections. This is more desirable for
mobile devices because they usually have longer latency network connectivity
and tighten battery constraints. Multiplexing these services also allows them
to share a single transport connection congestion control context. It could
open new optimization opportunities, like prioritizing interactive streams
over static content fetching streams.</t>
<t>As shown in the following diagram, the client can exchange data with PubSub,
RPC and CDN three different services within one HTTP/2 connection.</t>
<figure anchor="fig-multiplex"><name>Client opens multiple RStreams and a HTTP/2 stream within one HTTP/2
connection.
</name>
<artwork>+--------+   RStream (5)   +---------+    RStream (1)   +----------+
| client |&gt;---------------&gt;|  proxy  |&gt;----------------&gt;|  PUBSUB  |
+--------+                 +---------+                  +----------+
  v   v                     ^ ^  v  v
  |   |     RStream (7)    /  |  |   \    RStream (5)   +----------+
  |   +-------------------+   |  |    +----------------&gt;|    RPC   |
  |                           |  |                      +----------+
  |                           |  |  
  |         Stream (9)        |  |      Stream (7)      +----------+
  +---------------------------+  +---------------------&gt;|    CDN   |
                                                        +----------+
</artwork>
</figure>
</section>

<section anchor="states-of-rstream-and-exstream"><name>States of RStream and ExStream</name>
<t>RStreams are regular HTTP/2 streams that follow the stream lifecycle in
<xref target="RFC7540"></xref>, section 5.1. ExStreams use the same lifecycle as regular HTTP/2
streams, but have extra dependence on their RStreams. If a RStream is reset, endpoints
<bcp14>MUST</bcp14> reset the ExStreams associated with that RStream. If the RStream is
closed, endpoints <bcp14>SHOULD</bcp14> allow the existing ExStreams to complete normally. The RStream
<bcp14>SHOULD</bcp14> remain open while communication is ongoing. Endpoints <bcp14>SHOULD</bcp14> refresh any
timeout on the RStream while its associated ExStreams are open.</t>
<t>A sender <bcp14>MUST NOT</bcp14> initiate new ExStreams if on an RStream that is in the
open or half closed (remote) state.</t>
<t>Endpoints process new ExStreams only when the RStream is open or half closed
(local) state. If an endpoint receives an EX<em>HEADERS frame specifying an RStream
in the closed or haf closed (remote) state, it <bcp14>MUST</bcp14> respond with a connection
error of type ROUTING</em>STREAM_ERROR.</t>
</section>

<section anchor="negotiate-the-extension-through-settings-frame"><name>Negotiate the Extension through SETTINGS frame</name>
<t>The extension <bcp14>SHOULD</bcp14> be disabled by default. As suggested in <xref target="RFC7540"></xref>,
section 5.5, the unknown ENABLE<em>EX</em>HEADERS setting and EX_HEADERS frame
<bcp14>MUST</bcp14> be ignored by HTTP/2 compliant implementations, which have supported
this extension yet.</t>
<t>Endpoints can negotiate the use of the extension through the SETTINGS frame.
If an implementation supports the extension, it is <bcp14>RECOMMENDED</bcp14> to include
the ENABLE<em>EX</em>HEADERS setting in the initial SETTINGS frame, such that the
remote endpoint can disover the support at the earliest time. Once enabled,
this extension <bcp14>MUST NOT</bcp14> be disabled over the lifetime of the connection.</t>
<t>An endpoint can send EX<em>HEADERS frames immediately upon receiving a SETTINGS
frame with ENABLE</em>EX_HEADERS=1.</t>
<t>An endpoint <bcp14>MUST NOT</bcp14> send out EX<em>HEADERS before receiving a SETTINGS frame
with the ENABLE</em>EX<em>HEADERS=1. If a remote endpoint does not support this
extension yet, the EX</em>HEADERS will be ignored, making the header compression
contexts inconsistent between sender and receiver.</t>
<t>If an endpoint supports this extension, but receives EX<em>HEADERS frames before
ENABLE</em>EX<em>HEADERS, it is <bcp14>RECOMMENDED</bcp14> to respond with a connection error
EX</em>HEADER<em>NOT</em>ENABLED_ERROR. This helps the remote endpoint to implement this
extension properly.</t>
<t>Intermediaries <bcp14>SHOULD</bcp14> send the ENABLE<em>EX</em>HEADERS setting to clients, only if
intermediaries and their upstream servers can support this extension. If an
intermediary receives an ExStream but discovers the destination endpoint does
not support the extension, it <bcp14>MUST</bcp14> reset the stream with
EX<em>HEADER</em>NOT<em>ENABLED</em>ERROR.</t>
</section>

<section anchor="interaction-with-standard-http-2-features"><name>Interaction with standard HTTP/2 features</name>
<t>The extension implementation <bcp14>SHOULD</bcp14> apply stream and connection level flow
control, maximum concurrent streams limit, GOAWAY logic to both RStreams and
ExStreams.</t>
</section>
</section>

<section anchor="http-2-ex-headers-frame"><name>HTTP/2 EX_HEADERS Frame</name>
<t>The EX<em>HEADERS frame (type=0xfb) has all the fields and frame header flags
defined by HEADERS frame in HEADERS <xref target="RFC7540"></xref>, section 6.2. Moreover,
a EX</em>HEADERS frame has one extra field, Routing Stream ID. It is used to
open an ExStream, and additionally carries a header block fragment. EX_HEADERS
frames can be sent on a stream in the &quot;idle&quot;, &quot;open&quot;, or &quot;half-closed (remote)&quot;
state.</t>
<t>Like HEADERS, the CONTINUATION frame (type=0x9) is used to continue a sequence
of header block fragments, if the headers do not fit into one EX_HEADERS frame.</t>
<figure anchor="fig-ex-headers-frame"><name>EX_HEADERS Frame Payload
</name>
<artwork> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |E|                 Stream Dependency? (31)                     |
 +-+-------------+-----------------------------------------------+
 |  Weight? (8)  |
 +-+-------------+-----------------------------------------------+
 |R|                 Routing Stream ID (31)                      |
 +-+-------------+-----------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
</artwork>
</figure>
<t>The RStream specified in a EX<em>HEADERS frame <bcp14>MUST</bcp14> be an open stream. The recipient
<bcp14>MUST</bcp14> respond with a connection error of type ROUTING</em>STREAM<em>ERROR PROTOCOL</em>ERROR, if the
specified RStream is missing; or is an ExStream rather than a regualr HTTP/2 stream; or is
closed or half-closed (remote). Otherwise, the states maintained for header
compression or flow control) may be out of sync.</t>
</section>

<section anchor="iana-considerations"><name>IANA Considerations</name>
<t>This document establishes a registry for a new frame type, setting, and error
code.</t>

<section anchor="frame-type-registry"><name>FRAME TYPE Registry</name>
<t>The entry in the following table are registered by this document.</t>

<artwork>   +---------------+------+--------------+
   | Frame Type    | Code | Section      |
   +---------------+------+--------------+
   | EX_HEADERS    | 0xfb |              |
   +---------------+------+--------------+
</artwork>
</section>

<section anchor="settings-registry"><name>Settings Registry</name>
<t>The entry in the following table are registered by this document.</t>

<artwork>+------------------------+--------+---------------+---------------+
| Name                   | Code   | Initial Value | Specification |
+------------------------+--------+---------------+---------------+
| ENABLE_EX_HEADERS      | 0xfbfb | 0             |               |
+------------------------+--------+---------------+---------------+
</artwork>
</section>

<section anchor="error-code-registry"><name>Error Code Registry</name>
<t>The entry in the following table are registered by this document.</t>

<artwork>+----------------------+------+-------------------+---------------+
| Name                 | Code | Description       | Specification |
+----------------------+------+-------------------+---------------+
| ROUTING_STREAM_ERROR | 0xfb | Routing stream is |               |
|                      |      | not open          |               |
| EX_HEADERS_NOT_      | 0xfc | EX_HEADERS is not |               |
| ENABLED_ERROR        |      | enabled yet       |               |
+----------------------+------+-------------------+---------------+
</artwork>
</section>
</section>

</middle>

<back>
<references><name>Normative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml"/>
</references>

</back>

</rfc>
